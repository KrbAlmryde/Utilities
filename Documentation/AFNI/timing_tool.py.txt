
=============================================================================
timing_tool.py    - for manipulating and evaluating stimulus timing files
                    (-stim_times format: where each row is a separate run)

   This program is meant to work with ascii files containing rows of floats
   ('*' characters are ignored).  This is the format used by 3dDeconvolve
   with the -stim_times option.  Some timing files do not need evaluation,
   such as those where the timing is very consistent.  However, it may be
   important to examine those files from a random timing design.

   Recall that an ISI (inter-stimulus interval) is the interval of time
   between the end of one stimulus and start of the next.

   The basic program operations include:

       o reporting ISI statistics, such as min/mean/max values per run
       o reporting overall ISI statistics for a set of timing files
       o converting stim_times format to stim_file format
       o adding a constant offset to time
       o combining multiple timing files into 1 (like '1dcat' + sort)
       o appending additional timing runs (like 'cat')
       o sort times per row (though 3dDeconvolve does not require this)
       o converting between local and global stim times

   A sample stimulus timing file having 3 runs with 4 stimuli per run
   might look something like the following.  Note that the file does not
   imply the durations of the stimuli, except that stimuli are generally
   not allowed to overlap.

      17.3 24.0 66.0 71.6
      11.0 30.6 49.2 68.5
      19.4 28.7 53.8 69.4

   The program works on either a single timing element (which can be modified),
   or a list of them (which cannot be modified).  The only real use of a list
   of timing elements is to show statistics (via -multi_show_isi_stats).

--------------------------------------------------------------------------
examples:

   0. Basic commands:

         timing_tool.py -help
         timing_tool.py -hist
         timing_tool.py -show_valid_opts
         timing_tool.py -ver

   1. Combine the timing of 2 files (extend one timing by another and sort).
      Write to a new timing file.

         timing_tool.py -timing stimesB_01_houses.1D         \
                        -extend stimesB_02_faces.1D          \
                        -sort                                \
                        -write_timing stimesB_extended.1D

   2. Subtract 12 seconds from each stimulus time (to offset TRs dropped
      prior to the magnetization steady state).

         timing_tool.py -timing stimesB_01_houses.1D         \
                        -add_offset -12.0                    \
                        -write_timing stimesB1_offset12.1D

   2b.Similar to 2, but scale times (multiply) by 0.975, perhaps to account
      for a different TR or stimulus duration.

         timing_tool.py -timing stimesB_01_houses.1D         \
                        -scale_data 0.975                    \
                        -write_timing stimesB1_scaled.1D

   2c.Similar to 2, but shift run times so that the first time occurs at the
      beginning of the run.

         timing_tool.py -timing stimesB_01_houses.1D         \
                        -shift_to_run_offset 0               \
                        -write_timing stimesB1_offset0.1D

   3. Show timing statistics for the 3 timing files generated by example 3
      from "make_random_timing -help".  To be accurate, specify the run
      and stimulus durations.

         timing_tool.py -multi_timing stimesC_*.1D           \
                        -run_len 200 -multi_stim_dur 3.5     \
                        -multi_show_isi_stats

   4. Show timing statistics for the timing files generated by example 6
      from "make_random_timing -help".  Since both the run and stimulus
      durations vary, 4 run lengths and 3 stimulus durations are given.

         timing_tool.py -multi_timing stimesF_*.1D           \
                        -run_len 200 190 185 225             \
                        -multi_stim_dur 3.5 4.5 3            \
                        -multi_show_isi_stats

   5. Partition the stimulus timing file 'response_times.1D' into multiple
      timing files based on the labels in a partition file, partitions.1D.
      If partitions.txt contains (0, correct, incorrect), there will be 2
      output timing files, new_times_correct.1D and new_times_incorrect.1D.
      Times where the partition label is '0' will be skipped.

         timing_tool.py -timing response_times.1D       \
                        -partition partitions.txt new_times

   6a.Convert a stim_times timing file to 0/1 stim_file format.  Suppose the
      timing is random where each event lasts 2.5 seconds and runs are of 
      lengths 360, 360 and 400 seconds.  Convert timing.txt to sfile.1D on a TR
      grid of 0.5 seconds (oversampling), where a TR gets an event if at least        30% of the TR is is occupied by stimulus.

          timing_tool.py -timing timing.txt -timing_to_1D sfile.1D      \
                         -tr 0.5 -stim_dur 2.5 -min_frac 0.3            \
                         -run_len 360 360 400

    6b.Evaluate the results.  Use waver to convolve sfile.1D with GAM and use
       3dDeconvolve to convolve the timing file with BLOCK(2.5).

          waver -GAM -TR 0.5 -peak 1 -input sfile.1D > waver.1D

          3dDeconvolve -nodata 2240 0.5 -concat '1D: 0 720 1440'        \
                       -polort -1 -num_stimts 1                         \
                       -stim_times 1 timing.txt 'BLOCK(2.5)'            \
                       -x1D X.xmat.1D -x1D_stop

          1dplot -sepscl sfile.1D waver.1D X.xmat.1D

   7. Truncate stimulus times to the beginning of respective TRs.

      Given a TR of 2.5 seconds and random stimulus times, truncate those times
      to multiples of the TR (2.5).

          timing_tool.py -timing timing.txt -tr 2.5 -truncate_times     \
                         -write_timing trunc_times.txt

      Here, 11.83 would get truncated down to 10, the largest multiple of 2.5
      less than or equal to the original time.

   7b.Instead of just truncating the times, round them to the nearest TR, based
      on some TR fraction.  In this example, round up to the next TR when a
      stimulus occurs at least 70% into a TR, otherwise round down to the
      beginning.

          timing_tool.py -timing timing.txt -tr 2.5 -round_times 0.7    \
                         -write_timing round_times.txt

      With no rounding, a time of 11.83 would be truncated to 10.0.  But 11.83
      is 1.83 seconds into the TR, or is 73.2 percent into the TR.  Since it is
      at least 70% into the TR, it is rounded up to the next one.

      Here, 11.83 would get rounded up to 12.5.

   8. Create an event list from stimulus timing files.  The TR is 1.25s, events
      are ~1 TR long, and require them to occupy at least half of the given TR.
      Specify that rows should be per run and the run durations are all 370.

          timing_tool.py -multi_timing stimes.*.txt        \
               -multi_timing_to_events all.events.txt      \
               -tr 1.25 -multi_stim_dur 1 -min_frac 0.5    \
               -per_run -run_len 370 

   8b.Break the event file into 2, one for a sequence of changing event types,
      one for a sequence of ISIs (TRs from one event to the next, including
      the TR of the event).  So if the event file from #8 shows:
        0 0 3 0 0 0 0 1 0 2 2 0 0 0 ...
      The resulting event/ISI files would read:
        event: 0 3 1 2 2 ...
        ISI:   2 5 2 1 4 ...

          timing_tool.py -multi_timing stimes.*.txt            \
               -multi_timing_to_event_pair events.txt isi.txt  \
               -tr 1.25 -multi_stim_dur 1 -min_frac 0.5        \
               -per_run -run_len 370 

   9a. Convert from global stim times to local.
       This requires knowing the run lengths, say 4 runs of 200 seconds here.
       The result will have 4 rows, each starting at time 0.

          timing_tool.py -timing stim.1D                       \
                -global_to_local local.1D                      \
                -run_len 200 200 200

       Note that if stim.1D looks like this ( ** but as a single column ** ): 

                12.3 115 555 654 777 890

       then local.1D will look like this:

                12.3 115
                *
                155 254 377 490

       It will complain about the 3 times after the last run ends (no run
       should have times above 200 sec).

   9b. Convert from local timing back to global.

          timing_tool.py -timing local.1D                       \
                -local_to_global global.1D                      \
                -run_len 200 200 200


--------------------------------------------------------------------------
Notes:

   1. Action options are performed in the order of the options.  If the -chrono
      option is given, everything (but -chrono) is.

   2. Either -timing or -multi_timing is required for processing.

   3. Option -run_len applies to single or multiple stimulus classes.  A single
      parameter would be used for all runs.  Otherwise one duration per run
      should be supplied.

--------------------------------------------------------------------------
basic informational options:

   -help                        : show this help
   -hist                        : show the module history
   -show_valid_opts             : show all valid options
   -ver                         : show the version number

------------------------------------------
options with both single and multi versions (all single first):

   -timing TIMING_FILE          : specify a stimulus timing file to load

        e.g. -timing stimesB_01_houses.1D

        Use this option to specify a single stimulus timing file.  The user
        can modify this timing via some of the action options listed below.

   -show_isi_stats              : display timing and ISI statistics

        With this option, the program will display timing statistics for the
        single (possibly modified) timing element.

        If -tr is included, TR offset statistics are also shown.

   -show_timing_ele             : display info on the main timing element

        With this option, the program will display information regarding the
        single (possibly modified) timing element.

   -stim_dur DURATION           : specify the stimulus duration, in seconds

        e.g. -stim_dur 3.5

        This option allows the user to specify the duration of the stimulus,
        as applies to the single timing element.  The only use of this is
        in conjunction with -show_isi_stats.

            Consider '-show_isi_stats' and '-run_len'.

   --------------------
        
   -multi_timing FILE1 FILE2 ... : specify multiple timing files to load

        e.g. -timing stimesB_*.1D

        Use this option to specify a list of stimulus timing files.  The user
        cannot modify this data, but can display the overall ISI statistics
        from it.

        Options that pertain to this timing list include:

            -multi_show_isi_stats
            -multi_show_timing_ele
            -multi_stim_dur
            -run_len
            -write_all_rest_times

   -multi_show_isi_stats        : display timing and ISI statistics

        With this option, the program will display timing statistics for the
        multiple timing files.

        If -tr is included, TR offset statistics are also shown.

        If -write_all_rest_times is included, write a file of rest durations.

   -multi_show_timing_ele       : display info on the multiple timing elements

        With this option, the program will display information regarding the
        multiple timing element list.

   -multi_stim_dur DUR1 ...     : specify the stimulus duration(s), in seconds

        e.g. -multi_stim_dur 3.5
        e.g. -multi_stim_dur 3.5 4.5 3

        This option allows the user to specify the durations of the stimulus
        classes, as applies to the multiple timing elements.  The only use of
        this is in conjunction with -multi_show_isi_stats.

        If only one duration is specified, it is applied to all elements.
        Otherwise, there should be as many stimulus durations as files
        specified with -multi_timing.

            Consider '-multi_show_isi_stats' and '-run_len'.

------------------------------------------
action options (apply to single timing element, only):

   ** Note that these options are processed in the order they are read.
      See '-chrono' for similar notions.

   -add_offset OFFSET           : add OFFSET to every time in main element

        e.g. -add_offset -12.0

        Use this option to add a single offset to all of the times in the main
        timing element.  For example, if the user deletes 3 4-second TRs from
        the EPI data, they may wish to subtract 12 seconds from every stimulus
        time, so that the times match the modified EPI data.

            Consider '-write_timing'.

   -add_rows NEW_FILE           : append these timing rows to main element

        e.g. -add_rows more_times.1D

        Use this option to append rows from NEW_FILE to those of the main
        timing element.  If the user then wrote out the result, it would be
        identical to using cat: "cat times1.txt times2.txt > both_times.txt".

            Consider '-write_timing'.

   -extend NEW_FILE             : extend the timing rows with those in NEW_FILE

        e.g. -extend more_times.1D

        Use this option to extend each row (run) with the times in NEW_FILE.
        This has an effect similar to that of '1dcat'.  Sorting the times is
        optional, done via '-sort'.  Note that 3dDeconvolve does not need the
        times to be sorted, though it is more understandable to the user.

            Consider '-sort' and '-write_timing'.

   -global_to_local LOCAL_NAME.1D  : convert from global timing to local

        e.g. -global_to_local local_times.1D

        Use this option to convert from global stimulus timing (in a single
        column format) to local stimulus timing.  Run durations must be given
        of course, to determine which run each stimulus occurs in.  Each
        stimulus time will be adjusted to be an offset into the current run,
        e.g. if each run is 120 s, a stimulus at time 143.6 would occur in run
        #2 (1-based) at time 23.6 s.

            Consider example 9a and options '-run_len' and '-local_to_global'.

   -local_to_global GLOBAL_NAME.1D : convert from local timing to global

        e.g. -local_to_global global_times.1D

        Use this option to convert from local stimulus timing (one row of times
        per run) to global stimulus timing (a single column of times across the
        runs, where time is considered continuous across the runs).

        Run durations must be given of course, to determine which run each
        stimulus occurs in.  Each stimulus time will be adjusted to be an
        offset from the beginning of the first run, as if there were no breaks
        between the runs.
        e.g. if each run is 120 s, a stimulus in run #2 (1-based) at time
        23.6 s would be converted to a stimulus at global time 143.6 s.

            Consider example 9b and options '-run_len' and '-global_to_local'.

   -partition PART_FILE PREFIX  : partition the stimulus timing file

        e.g. -partition partitions.txt new_times

        Use this option to partition the input timing file into multiple
        timing files based on the labels in a partition file, PART_FILE.
        The partition file would have the same number of rows and entries on
        each row as the timing file, but would contain labels to use in
        partitioning the times into multiple output files.

        A label of 0 will cause that timing entry to be dropped.  Otherwise,
        each distinct label will have those times put into its timing file.

        e.g. 

                timing file:
                    23.5     46.0     79.3     84.9      116.2
                    11.4     38.2     69.7     93.5      121.8

                partition file:
                    correct  0        0        incorrect incorrect
                    0        correct  0        correct   correct

            ==> results in new_times_good.1D and new_times_bad.1D

                new_times_correct.1D:
                    23.5     0        0        0         0
                    0        38.2     0        93.5      121.8

                new_times_incorrect.1D:
                    0        0        0        84.9      116.2
                    *

   -round_times FRAC            : round times to multiples of the TR
                                  0.0 <= FRAC <= 1.0

        e.g. -round_times 0.7

        All stimulus times will be rounded to a multiple TR, rounding down if
        the fraction of the TR that has passed is less than FRAC, rounding up
        otherwise.

        Using the example of FRAC=0.7, if the TR is 2.5 seconds, then times are
        rounded down if they occur earlier than 1.75 seconds into the TR.  So
        11.83 would get rounded up to 12.5, while 11.64 would be rounded down
        to 10.

        FRAC = 1.0 is essentially floor() (as in -truncate_times), while
        FRAC = 0.0 is essentially ceil().

        This option requires -tr.

            Consider example 7b.  See also -truncate_times.

   -scale_data SCALAR           : multiply every stim time by SCALAR

        e.g. -scale_data 0.975

        Use this option to scale (multiply) all times by a single value.
        This might be useful in effectively changing the TR, or changing
        the stimulus frequency, if it is regular.

            Consider '-write_timing'.

   -show_timing                 : display the current single timing data

        This prints the current (possibly modified) single timing data to the
        terminal.  If the user is making multiple modifications to the timing
        data, they may wish to display the updated timing after each step.

   -sort                        : sort the times, per row (run)

        This will cause each row (run) of the main timing element to be
        sorted (from smallest to largest).  Such a step may be highly desired
        after using '-extend', or after some external manipulation that causes
        the times to be unsorted.

        Note that 3dDeconvolve does not require sorted timing.

            Consider '-write_timing'.

   -timing_to_1D output.1D      : convert stim_times format to stim_file

        e.g. -timing_to_1D stim_file.1D

        This action is used to convert stimulus times to set (i.e. 1) values
        in a 1D stim_file.  

        Besides an input -timing file, -tr is needed to specify the timing grid
        of the output 1D file, -stim_dur is needed to specify the duration of
        each stimulus (which might cross many output TRs), and -run_len is
        needed to specify the duration of each (or all) of the runs.

        The -min_frac option may be applied to give a minimum cutoff for the
        fraction of a TR occupied by a stimulus required to label that TR as a
        1.  If not, the default cutoff is 0.3.

        For example, assume options: '-tr 2', '-stim_dur 4.2', '-min_frac 0.2'.
        A stimulus at time 9.7 would last until 13.9.  TRs 0..4 would certainly
        be 0, TR 5 would also be 0 as the stimulus covers only .15 of the TR
        (.3 seconds out of 2 seconds).  TR 6 would be 1 since it is completely
        covered, and TR 7 would be 1 since .95 (1.9/2) would be covered.

        So the resulting 1D file would start with:

                0
                0
                0
                0
                0
                1
                1

        The main use of this operation is for PPI analysis, to partition the
        time series (maybe on a fine grid) with 1D files that are 1 when the
        given stimulus is on and 0 otherwise.

            Consider -tr, -stim_dur, -min_frac, -run_len.

            Consider example 6a.

   -transpose                   : transpose the data (only if rectangular)

        This works exactly like 1dtranspose, and requires each row to have
        the same number of entries (rectangular data).  The first row would
        be swapped with the first column, etc.

            Consider '-write_timing'.

   -truncate_times              : truncate times to multiples of the TR

        All stimulus times will be truncated to the largest multiple of the TR
        that is less than or equal to each respective time.  That is to say,
        shift each stimulus time to the beginning of its TR.

        This is particularly important when stimulus times are at a constant
        offset into each TR and at the same time using TENT basis functions
        for regression (in 3dDeconvolve, say).  The shorter the (non-zero)
        offset, the more correlated the first two tent regressors will be,
        possibly leading to unpredictable results.

        This option requires -tr.

            Consider example 7.

   -write_timing NEW_FILE       : write the current timing to a new file

        e.g. -write_timing new_times.1D

        After modifying the timing data, the user will probably want to write
        out the result.  Alternatively, the user could use -show_timing and
        cut-and-paste to write such a file.

------------------------------------------
action options (apply to multi timing elements, only):

   -multi_timing_to_events FILE : create event list from stimulus timing

        e.g. -multi_timing_to_events all.events.txt

        Decide which TR each stimulus event belongs to and make an event file
        (of TRs) containing a sequence of values between 0 (no event) and N
        (the index of the event class, for the N timing files).

        This option requires -tr, -multi_stim_dur, -min_frac and -run_len.

           Consider example 8.

   -multi_timing_to_event_pair Efile Ifile : break event file into 2 pieces

        e.g. -multi_timing_to_event_pair events.txt isi.txt

        Similar to -multi_timing_to_events, but break the output event file
        into 2 pieces, an event list and an ISI list.  Each event E followed by 
        K zeros in the previous events file would be broken into a single E (in
        the new event file) and K+1 (in the ISI file).  Note that K+1 is 
        appropriate from the assumption that events are 0-duration.  The ISI
        entries should sum to the total number of TRs per run.

        Suppose the event file shows 2 TRs of rest, event type 3 followed by 4
        TRs of rest, event type 1 followed by 1 TR of rest, type 2 and no rest,
        type 2 and 3 TRs of rest.  So it would read:

           all events:  0 0 3 0 0 0 0 1 0 2 2 0 0 0 ...

        Then the event_pair files would read:

           events:      0 3 1 2 2 ...
           ISIs:        2 5 2 1 4 ...

        Note that the only 0 events occur at the beginnings of runs.
        Note that the ISI is always at least 1, for the TR of the event.

        This option requires -tr, -multi_stim_dur, -min_frac and -run_len.

           Consider example 8b.

------------------------------------------
general options:

   -chrono                      : process options chronologically

        While the action options are already processed in order, general and
        -timing options are not, unless the chrono option is given.  This 
        allows one to do things like scripting a sequence of operations
        within a single command.

   -min_frac FRAC               : specify minimum TR fraction

        e.g. -min_frac 0.1

        This option applies to the -timing_to_1D action, above.  When a random
        timing stimulus is converted to part of a 0/1 1D file, if the stimulus
        occupies at least FRAC of a TR, then that TR gets a 1 (meaning it is 
        "on"), else it gets a 0 ("off").

        FRAC is required to be within [0,1], though clearly 0 is not very
        useful.  Also, 1 is not recommended unless that TR can be stored
        precisely as a floating point number.  For example, 0.1 cannot be
        stored exactly, so 0.999 might be safer to basically mean 1.0.

            Consider -timing_to_1D.


   -nplaces NPLACES             : specify # decimal places used in printing

        e.g. -nplaces 1

        This option allows the user to specify the number of places to the
        right of the decimal that are used when printing a stimulus time
        (to the screen via -show_timing or to a file via -write_timing).
        The default is -1, which uses the minimum needed for accuracy.

            Consider '-show_timing' and '-write_timing'.

   -per_run                     : perform relevant operations per run

        e.g. -per_run

        This option applies to -timing_to_1D, so that each 0/1 array is
        one row per run, as opposed to a single column across runs.

   -run_len RUN_TIME ...        : specify the run duration(s), in seconds

        e.g. -run_len 300
        e.g. -run_len 300 320 280 300

        This option allows the user to specify the duration of each run.
        If only one duration is provided, it is assumed that all runs are of
        that length of time.  Otherwise, the user must specify the same number
        of runs that are found in the timing files (one run per row).

        This option applies to both -timing and -multi_timing files.

        The run durations only matter for displaying ISI statistics.

            Consider '-show_isi_stats' and '-multi_show_isi_stats'.

   -tr TR                       : specify the time resolution in 1D output
                                  (in seconds)
        e.g. -tr 2.0
        e.g. -tr 0.1

        For any action that write out 1D formatted data (currently just the
        -timing_to_1D action), this option is used to set the temporal
        resolution of the data.  For example, given -run_len 200 and -tr 0.5,
        one run would be 400 time points.

            Consider -timing_to_1D and -run_len.

   -verb LEVEL                  : set the verbosity level

        e.g. -verb 3

        This option allows the user to specify how verbose the program is.
        The default level is 1, 0 is quiet, and the maximum is (currently) 4.

   -write_all_rest_times        : write all rest durations to 'timing' file

        e.g. -write_all_rest_times all_rest.txt

        In the case of a show_isi_stats option, the user can opt to save all
        rest (pre-stim, isi, post-stim) durations to a timing-style file.  Each
        row (run) would have one more entry than the number of stimuli (for 
        pre- and post- rest).  Note that pre- and post- might be 0.

-----------------------------------------------------------------------------
R Reynolds    December 2008
=============================================================================

