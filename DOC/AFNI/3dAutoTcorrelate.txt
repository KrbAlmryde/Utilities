Usage: 3dAutoTcorrelate [options] dset
Computes the correlation coefficient between the time series of each
pair of voxels in the input dataset, and stores the output into a
new anatomical bucket dataset [scaled to shorts to save memory space].

*** Also see program 3dTcorrMap ***

Options:
  -pearson  = Correlation is the normal Pearson (product moment)
               correlation coefficient [default].
  -eta2     = Output is eta^2 measure from Cohen et al., NeuroImage, 2008:
               http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2705206/
               http://dx.doi.org/10.1016/j.neuroimage.2008.01.066
             ** '-eta2' is intended to be used to measure the similarity
                 between 2 correlation maps; therefore, this option is
                 to be used in a second stage analysis, where the input
                 dataset is the output of running 3dAutoTcorrelate with
                 the '-pearson' option -- the voxel 'time series' from
                 that first stage run is the correlation map of that
                 voxel with all other voxels.
             ** '-polort -1' is recommended with this option!
  -spearman AND -quadrant are disabled at this time :-(

  -polort m = Remove polynomical trend of order 'm', for m=-1..3.
               [default is m=1; removal is by least squares].
               Using m=-1 means no detrending; this is only useful
               for data/information that has been pre-processed.

  -autoclip = Clip off low-intensity regions in the dataset,
  -automask =  so that the correlation is only computed between
               high-intensity (presumably brain) voxels.  The
               mask is determined the same way that 3dAutomask works.

  -mask mmm = Mask of both 'source' and 'target' voxels.
              ** Restricts computations to those in the mask.  Output
                  volumes are restricted to masked voxels.  Also, only
                  masked voxels will have non-zero output.
              ** A dataset with 1000 voxels would lead to output of
                  1000 sub-bricks.  With a '-mask' of 50 voxels, the
                  output dataset have 50 sub-bricks, where the 950
                  unmasked voxels would be all zero in all 50 sub-bricks
                  (unless option '-mask_only_targets' is also used).
              ** The mask is encoded in the output dataset header in the
                  attribute named 'AFNI_AUTOTCORR_MASK' (cf. 3dMaskToASCII).

  -mask_only_targets = Provide output for all voxels.
              ** Used with '-mask': every voxel is correlated with each
                  of the mask voxels.  In the example above, there would
                  be 50 output sub-bricks; the n-th output sub-brick
                  would contain the correlations of the n-th voxel in
                  the mask with ALL 1000 voxels in the dataset (rather
                  than with just the 50 voxels in the mask).

  -prefix p = Save output into dataset with prefix 'p'
               [default prefix is 'ATcorr'].

  -time     = Mark output as a 3D+time dataset instead of an anat bucket.

  -mmap     = Write .BRIK results to disk directly using Unix mmap().
               This trick can speed the program up  when the amount
               of memory required to hold the output is very large.
              ** In many case, the amount of time needed to write
                 the results to disk is longer than the CPU time.
                 This option can shorten the disk write time.
              ** If the program crashes, you'll have to manually
                 remove the .BRIK file, which will have been created
                 before the loop over voxels and written into during
                 that loop, rather than being written all at once
                 at the end of the analysis, as is usually the case.
              ** If the amount of memory needed is bigger than the
                 RAM on your system, this program will be very slow
                 with or without '-mmap'.
              ** This option won't work with NIfTI-1 (.nii) output!

Notes:
 * The output dataset is anatomical bucket type of shorts
    (unless '-time' is used).
 * Values are scaled so that a correlation (or eta-squared)
    of 1 corresponds to a value of 10000.
 * The output file might be gigantic and you might run out
    of memory running this program.  Use at your own risk!
   ++ If you get an error message like
        *** malloc error for dataset sub-brick
      this means that the program ran out of memory when making
      the output dataset.
 * The program prints out an estimate of its memory usage
    when it starts.  It also prints out a progress 'meter'
    to keep you pacified.
 * This is a quick hack for Peter Bandettini. Now pay up.
 * OpenMP-ized for Hang Joon Jo.  Where's my soju?

-- RWCox - 31 Jan 2002 and 16 Jul 2010

 =========================================================================
* This binary version of 3dAutoTcorrelate is compiled using OpenMP, a semi-
   automatic parallelizer software toolkit, which splits the work across
   multiple CPUs/cores on the same shared memory computer.
* OpenMP is NOT like MPI -- it does not work with CPUs connected only
   by a network (e.g., OpenMP doesn't work with 'cluster' setups).
* For implementation and compilation details, please see
   http://afni.nimh.nih.gov/pub/dist/doc/misc/OpenMP.html
* The number of CPU threads used will default to the maximum number on
   your system.  You can control this value by setting environment variable
   OMP_NUM_THREADS to some smaller value (including 1).
* Un-setting OMP_NUM_THREADS resets OpenMP back to its default state of
   using all CPUs available.
   ++ However, on some systems (such as the NIH Biowulf), it seems to be
      necessary to set OMP_NUM_THREADS explicitly, or you only get one CPU.
* You must set OMP_NUM_THREADS in the shell BEFORE running the program,
   since OpenMP queries this variable BEFORE the program actually starts.
   ++ You can't usefully set this variable in your ~/.afnirc file or on the
      command line with the '-D' option.
* How many threads are useful?  That varies with the program, and how well
   it was coded.  You'll have to experiment on your own systems!
* The number of CPUs on this particular computer system is ...... 8.
 =========================================================================

++ Compile date = Jul  5 2011

