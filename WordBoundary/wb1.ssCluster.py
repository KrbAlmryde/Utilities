"""
==============================================================================
Program: wb1.ssCluster.py
 Author: Kyle Reese Almryde
   Date: 11/08/2012 @ 11:14 PM

Modfied: 11/10/2012 @ 01:58 AM
         11/10/2012 @ 09:17 AM
         11/13/2012 @ 10:42 AM
         11/14/2012 @ 11:03 AM

Description: This program is in part, a proof of concept to see whether
             or not the author could utilize python for processing fMRI data
             using the standard AFNI tools.

             The primary purpose of this script was to process a (large)
             list of cluster through each individual subject, for each
             run, and generate a report which can be used in excel for
             later analysis.

      Notes: Something kind of fun about this script is it doesnt use any
             command-line arguments or more than two loops. Using simple
             string and list manipulations, I was able to acquire all of the
             necessary information to construct the image filenames I wanted.
             Everything came out of the mask file name, which was how I
             processed the data. This method I feel was a little clearner and
             more efficient in terms of computer resources in the long run. It
             has definitely convinced me to modify my naming conventions such
             that you never need to reference and external source when trying
             to understand what the particular file or image is or what was
             done to it.
==============================================================================
"""
import os


def filterClusters(inputFile, maskImage, outputFile):
    """Filter single subject images through clusters

    This function filters the individual subject files through the
    selected cluster images.

    Params:
        inputFile -- a 4D Image, path included, and subbrick index if
                     necessary. eg, '/path/to/image/file/4dImage.nii[1]'
        maskImage -- a binary Image intended for use as a mask, path included eg,
                     '/path/to/image/file/MaskImage.nii'
                     NOTE: it is optional for the image to be in binary format
        outputFile -- a 4D Image, path included, describing the desired output
                      file name: '/path/to/image/file/4dImageMasked.nii'
    """
    os.system('3drefit -space MNI ' + maskImage)
    os.system('3dcalc -a ' + maskImage \
               + ' -b ' + inputFile \
               + " -expr 'step(a) * b'" \
               + ' -prefix ' + outputFile)


def flipXYZ(oldXYZ):   # This is an example of a nice Modular function.
    """Flip XY coords of an XYZ coordinate string

    This function inverts the xy coordinates generated by afni's
    3dclust command. It is presently acting as a sort of Helper
    function to getClusterStats function defined below.

    Params:
        oldXYZ -- a string containing the original xyz coordinates
                  oldXYZ == '58 42 8'
    Returns:
        xyz -- a new string with the inverted xy + z coordinates
                xyz == '-58 -42 8'
    """
    coordList = oldXYZ.split()
    x = int(coordList[0]) * -1
    y = int(coordList[1]) * -1
    xyz = ' '.join([str(x), str(y), coordList[2]])
    return xyz


def whereAmI(xyz):      # This is a good Modular function
    """Get the region of interest from the supplied xyz coordinates

    This function utilizes afni's CA_ML_18_MNIA atlas and reads xyz
    coordinates in -lpi orientation. It returns only the first listed
    roi, so if more detail is desired regarding the surrounding regions
    this function may not be the most ideal.

    Params:
        xyz -- a string of three numbers representing xyz coordinates
                '-50 48 2'

    Returns:
        A string representing the region of interest
    """
    atlas = os.popen('whereami ' + xyz + ' -atlas CA_ML_18_MNIA -lpi').readlines()
    index = atlas.index('Atlas CA_ML_18_MNIA: Macro Labels (N27)\n')
    roi = atlas[index + 1].split(':')[1].strip().split()
    return roi[0] + '\t' + ' '.join(roi[1:])


def getClusterStats(imgFile):   # This has potential to be very Modular, I just need to decide if I like it enough
    """Extract cluster stats from image file

    This function uses the os mondule popen to capture output from
    afni's 3dclust command. Presently it assumes the image is in
    2x2x2 resolution. Output is the mean and peak voxel intensity
    followed by the peak xyz coordinates

    Params:
        imgFile -- a 4D Image, path included eg,
                   '/path/to/image/file/4dImage.nii.gz'

    Returns:
        stats -- a string containing the values for mean, peak, xyz, and roi
    """
    clusterTbl = os.popen('3dclust 2 1 ' + imgFile).readlines()[-1].strip()  # Strip newline and get last line with the stats output table from 3dclust
    tempXyz = ' '.join(clusterTbl.split()[-3:]).replace('.0', '')  # Strip the '.0' from the coordinate numbers.

    mean = os.popen('3dBrickStat -mean ' + imgFile).readline().strip()  # get the mean of the image file
    peak = clusterTbl.split()[-4]   # a list object containing the [peak intensity, Xcoord, Ycoord, Zcoord]
    xyz = flipXYZ(tempXyz)  # Use the flipXYZ function to flip the x and y coordinates (name is a bit misleading)
    roi = whereAmI(xyz)  # Extract the Region of Interest based on the supplied xyz coordinates

    return mean + ' ' + peak + ' ' + xyz + ' ' + roi


def getIndex(condition='', component=''):
    """Return the .nii extension and optionally the subbrick index.

    Params:
       condition -- the experimental conditon eg, Learnable
       component -- the independant component number, eg IC2

    Returns:
         A string composed of the .nii extension and index in necessary
         '.nii[1]'
    """
    if component == 'IC2' or component == 'IC14':
        index = '.nii[0]'
    elif component == 'IC7' or component == 'IC29':
        index = '.nii[1]'
    elif component == 'IC25':
        index = '.nii[2]'
    elif component == 'IC31':
        index = '.nii[3]'
    elif component == 'IC39':
        index = '.nii[4]'
    else:
        index = '.nii'

    return index


def writeReport(sourceFile, sub, scan, ic, stats, fout, delim='\t'):
    """Write data to file report

    This function extracts information from a list and
    writes it to a file. It computes the standard
    deviation from the provided variance and writes that
    value in place of the variance provided by the infile

     Params:
        sourceFile -- This is the original cluster_image_file which is
                      included as a reference in the report file.
        sub -- the subject number
        scan -- the scan number
        ic -- the independant component
        stats -- presently this includes the mean and peak activation
                 intensities
        fout -> The output filehandle
        delim -- is the output field separator. By Default it is set to
                 \t (tabs)
    """
    data = [ic, sourceFile, sub, scan] + stats.split()
    fout.write(delim.join(data) + '\n')


#=============================== START OF MAIN ===============================

def main():
    fin = open('/usr/local/utilities/wb1.ssClusterList.txt')
    clusterImage = fin.readlines()

    for img in clusterImage:   # c1_cm_c4_cm_c69_cm_learn_IC2_s1_p_gm_l_t_thr_t_manual_t.nii.gz
        img = img.strip()      # Strip newlines chars and any whitespace surrounding the file name
        imgInfo = img.split('_')    # a list => ['c1', 'cm', 'c4', 'cm', 'c69', 'cm', 'learn', 'IC2', 's1', 'p', 'gm', 'l', 't', 'thr', 't', 'manual', 't.nii.gz']
        cond = imgInfo[6]
        side = imgInfo[11].upper()

        if cond == 'learn':
            ic = imgInfo[7]
            scan = imgInfo[8]
            Condition = 'Learnable'
        else:
            ic = imgInfo[8]
            scan = imgInfo[7]
            Condition = 'Unlearnable'

        # Define path variables
        GIFT = '/Volumes/Data/WB1/GiftAnalysis/'
        MANUAL = GIFT + 'Atlas_analysis/' + Condition + '_Expert/' + 'Clusters_manual/'
        SUBICA = GIFT + Condition + '/' + Condition + '_ss_analysis/'
        STRIP = SUBICA + 'Stripped_component_subject_images/'
        CLUSTDIR = SUBICA + 'Clustered_subject_images/'

        if not os.path.exists(CLUSTDIR):    # If the CLUSTDIR folder does not exist, make it.
            os.mkdir(CLUSTDIR)

        fout = open(CLUSTDIR + 'ss_cluster_report_' + Condition + '.txt', 'a+')

        for num in range(1, 17):
            if num < 10:
                sub = 'sub00' + str(num)
            else:
                sub = 'sub0' + str(num)

            print '\nCreating image names'
            maskImage = MANUAL + img    # a string => '/Volumes/Data/WB1/GiftAnalysis/Atlas_analysis/Learnable_Expert/Clusters_manual/c1_cm_c4_cm_c69_cm_learn_IC2_s1_p_gm_l_t_thr_t_manual_t.nii.gz'
            print maskImage

            index = getIndex(cond, ic)
            inFile = STRIP + '_'.join([sub, 'stripped_ica', scan]) + index
            print inFile

            index = getIndex(cond)
            outFile = CLUSTDIR + '_'.join([sub, '_'.join(imgInfo[:6]), cond, ic, scan, side]) + index
            print outFile

            print '\n Filtering data, '
            filterClusters(inFile, maskImage, outFile)
            stats = getClusterStats(outFile)
            writeReport(img, sub, scan, ic, stats, fout)

    fin.close()
    fout.close()

if __name__ == '__main__':
    main()
