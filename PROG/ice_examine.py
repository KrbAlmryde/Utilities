"""
==============================================================================
Program name: ice_examine.py
      Author: Kyle Reese Almryde
        Date: 11/02/2012 @ 04:39:22 PM
              12/18/2012 @ 11:35:01 AM

Purpose: This program examines the reports generated by afni's 3dInfo and
         determines what the most consistent datatype is, as well as any
         other formatting info so that we can make a decision on
         preprocessing for the IceWord data.

         In Addition it grabs and populates the subject directories with the
         current data.
==============================================================================
"""
import os


def getOutName(inputImg, addName=None, addDir='', altPath=''):
    """Make output file name based on inputImg

    Params:
        inputImg --
        extension -- The added extension, can be None
        addDir -- The path extention to be added. If not
                  provided, then no extention is added.
    Returns:
         return a tuple containing the subj ID, scan, and outName
    """
    path, image = os.path.split(inputImg)
    body, tail = '', ''

    if len(image.split('-')) < 3:
        subj = image.split('-')[0]
        scan = image.split('-')[1].split('.')[0]
        print subj, scan
    elif len(image.split('-')) > 3:
        subj, scan = image.split('-')[:2]
        body = image.split('-')[2:-1]
        tail = image.split('-')[-1].split('.')[0]
        print subj, scan, body, tail
    else:
        subj, scan = image.split('-')[:2]
        tail = image.split('-')[-1].split('.')[0]
        print subj, scan, tail

    outName = [subj, scan]

    if body:
        outName.extend(body)

    if tail and 'OLD' not in tail:
        outName.append(tail)
    else:
        pass

    if addName:
        outName.append(addName)

    outName = '-'.join(outName) + '.nii'

    if altPath:
        outImg = os.path.join(altPath, addDir, outName)
    else:
        outImg = os.path.join(path, addDir, outName)
    return subj, scan, outImg


def checkPath(path, alt, imgFile):
    """Check that the path to file exists, if it doesnt, test the alternate

    Params:
        path -- is always a path /volumes/data/foo/
        alt -- can be a path or a file
        imgFile -- is always a file

    Returns:
        return the image
    """
    if not os.path.isdir(alt):
        check1 = os.path.join(path, imgFile)
        check2 = os.path.join(path, alt)
    else:
        check1 = os.path.join(path, imgFile)
        check2 = os.path.join(alt, imgFile)

    if os.path.exists(check1 + '.BRIK'):
        print '\tGoing with check1', check1
        return check1
    elif os.path.exists(check2 + '.BRIK'):
        print '\tGoing with check2', check2
        return check2
    else:
        print 'Didnt Find it...uh oh'
        return


def getImgData(inputImg, outputImg):
    """Grab functional and structural images

       This function utilizes 3dCopy to copy the inputImg, to the
       outputImg, effectively copying and renaming the file to the
       new location in the new IceWord directory.

       Params:
           inputImg -- The desired image to be grabbed, path
                       is included in the name.
           outputImg -- The output file name to be placed,
                        path is included in the name.
    """
    copy = ' '.join(['3dcopy', inputImg, outputImg])

    if os.path.exists(outputImg):
        print outputImg.split('/')[-1], 'Already exists, removing... '
        os.remove(outputImg)

    os.popen(copy)


def getImgSpec(imgFile, subjDict, subj, scan):
    """ Determine which 'Spec' function to call

    Params:
        imgFile -- The imgFile to examine
        subjDict -- The dictionary containing

    Returns:
         Description of returns
    """
    if scan in ('Run1', 'Run2', 'Run3', 'Run4'):
        getFuncSpec(imgFile, subjDict[subj][scan])

    elif scan in ('SPGR', 'FSE'):
        getAnatSpec(imgFile, subjDict[subj][scan], scan)

    else:
        pass


def getFuncSpec(imgFile, funcDict):
    """Get Subject Image Specifications such as # of Volumes, TRs etc

    Params:
        ImgFile -- The image file in question
        funcDict --

    Returns:
         Modifies the supplied dictionary in place
    """
    info = ' '.join(['3dinfo', imgFile])

    for line in os.popen(info):
        line = line.strip()
        if 'third  ' in line:
            funcDict['Orient'] = line.split()[-1][:-1]
        elif 'R-to-L extent' in line:
            funcDict['Dimensions'] = line.split()[8]
        elif 'A-to-P extent' in line:
            funcDict['Dimensions'] += ' x ' + line.split()[8]
        elif 'Number of time steps' in line:
            line = line.split('  ')
            funcDict['Reps'] = line[0].split('=')[1].strip()
            funcDict['TR'] = line[1].split('=')[1].strip()
            funcDict['Origin'] = line[2].split('=')[1].strip()
            if len(line) > 3:
                funcDict['Slices'] = line[3].split('=')[1].strip()
                funcDict['Thickness'] = line[4].split('=')[1].strip()
    print funcDict, '\n'


def getAnatSpec(imgFile, anatDict, scan):
    """ One line description

    Params:
        imgFile --
        anatDict --

    Returns:
         Modifies the supplied dictionary in place
    """
    for line in os.popen('3dinfo ' + imgFile):
        line = line.strip()
        if 'third  ' in line:
            anatDict['Orient'] = line.split()[-1][:-1]

        elif 'R-to-L extent' in line:
            anatDict['FOV'] = line.split()[-2][1:]
            anatDict['R-extent'] = line.split()[2] + ' to ' + line.split()[5]
            if scan == 'SPGR':
                anatDict['Thickness'] = line.split()[8]
            else:
                anatDict['Dimensions'] = line.split()[8]

        elif 'A-to-P extent' in line:
            anatDict['FOV'] += ' x ' + line.split()[-2][1:]
            anatDict['A-extent'] = line.split()[2] + ' to ' + line.split()[5]
            if scan == 'SPGR':
                anatDict['Dimensions'] = line.split()[8]
            else:
                anatDict['Dimensions'] += ' x ' + line.split()[8]

        elif 'I-to-S extent' in line:
            anatDict['I-extent'] = line.split()[2] + ' to ' + line.split()[5]
            if scan == 'SPGR':
                anatDict['FOV'] += ' x ' + line.split()[-2][1:]
                anatDict['Dimensions'] += ' x ' + line.split()[8]
            else:
                anatDict['FOV'] += ' x ' + line.split()[-2]
                anatDict['Thickness'] = line.split()[8]


def writeReport(subjDict):
    """ One line description

    Params:
        orientDict --
        fout --

    Returns:
         None
    """
    title = "{:<11}{:<8}{:<10}{:<15}{:<17}{:<13}{:<20}{:<21}{:<23}{:<20}\n"
    header = ['Subject', 'Scan', 'MRInum', 'Orientation', 'Dimensions', 'Thickness', 'TR/FOV', 'Reps/R-extent', 'Slices/A-extent', 'Origin/I-extent']

    fout = open('/Volumes/Data/Iceword/README.txt', 'a+')
    fout.write(title.format(*header))

    for subscan in [(sub, scan) for sub in subjDict for scan in subjDict[sub] if scan not in ('MRInum', 'OldID')]:
        subj = subscan[0]
        scan = subscan[1]
        if scan in ('Run1', 'Run2', 'Run3', 'Run4'):
            dataTbl = "{0:<11}{1:<8}{2:<10}{Orient:<15}{Dimensions:<17}{Thickness:<13}{TR:<20}{Reps:<21}{Slices:<23}{Origin:<20}\n"
        elif scan in ('SPGR', 'FSE'):
            dataTbl = "{0:<11}{1:<8}{2:<10}{Orient:<15}{Dimensions:<17}{Thickness:<13}{FOV:<20}{R-extent:<21}{A-extent:<23}{I-extent:<20}\n"
        fout.write(dataTbl.format(subj, scan, subjDict[subj]['MRInum'], **subjDict[subj][scan]))
    fout.close()

#===============================[Start of Main]===============================


def main():

    mriNums = ['E24545', 'E24810', 'E24811', 'E24812', 'E25018', 'E25019',
               'E25112', 'E25113', 'E25114', 'E25877', 'E25878', 'E25879',
               'E3151',  'E3885', 'E3987', 'E4025', 'E4091', 'E4429', 'E4430']
    funcSpecs = {'Orient': '', 'Dimensions': '', 'Thickness': 0, 'Reps': 0, 'TR': 0, 'Origin': 0, 'Slices': 0}
    anatSpecs = {'Orient': '', 'Dimensions': '', 'Thickness': 0, 'FOV': '', 'R-extent': '', 'A-extent': '', 'I-extent': ''}

    #----------------------------------------------------------------------
    # Construct a dictionary composed of all scan types (Run1-4, SPGR, FSE)
    # mapped each subject ID, with image specs mapped to each of the scan
    # types. In addtion the MRI number and the 'old' Subject number mapped
    # to the true subject number resulting in a compound dictionary that
    # looks like the following:
    # {'sub001': {
    #             'OldID: 'S1',
    #             'MRInum': 'E24545',
    #             'Run1': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'Run2': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'Run3': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'Run4': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'SPGR': {'Orient': '', 'Dimensions': '', 'FOV': '',...},
    #             'FSE': {'Orient': '', 'Dimensions': '', 'FOV': '',...}
    #            },
    #  'sub002': {
    #             'OldID: 'S2',
    #             'MRInum': 'E4527',
    #             'Run1': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'Run2': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'Run3': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'Run4': {'Reps': 0, 'TR': 0, 'Origin': 0,...},
    #             'SPGR': {'Orient': '', 'Dimensions': '', 'FOV': '',...},
    #             'FSE': {'Orient': '', 'Dimensions': '', 'FOV': '',...}
    #            },
    #  ...}
    #----------------------------------------------------------------------
    subjDict = {}
    for s in range(1, 20):
        subjDict['sub%003d' % s] = {'OldID': 'S%d' % (s), 'MRInum': mriNums[(s - 1)]}
        subjDict['sub%003d' % s].update({'FSE': dict(anatSpecs), 'SPGR': dict(anatSpecs)})
        for scan in range(1, 5):
            subjDict['sub%003d' % s].update({'Run%d' % scan: dict(funcSpecs)})

    #-------------------#
    #    Ready, Begin   #
    #-------------------#
    for subscan in [(sub, scan) for sub in subjDict for scan in subjDict[sub] if scan not in ('MRInum', 'OldID')]:
        subj, scan = subscan
        print '\n', subj, scan

        #--------------------------#
        #    Reference Variables   #
        #--------------------------#
        enum = subjDict[subj]['MRInum']
        subID = subjDict[subj]['OldID']

        #---------------------------------#
        #       Directory Pointers        #
        #---------------------------------#
        # OldICE = '/Volumes/Data/ETC/ICEWORD/' + enum + '/combos/prelim'
        OldICE = '/Volumes/Data/ETC/ICEWORD/' + subID + '/combos/prelim'
        ICEmorph = '/Volumes/Data/Iceword/' + subj + '/Morph'
        OldStruct = '/Volumes/Data/ETC/ICEWORD/' + enum + '/struct'

        #---------------------------------#
        #       Functional Images         #
        #---------------------------------#
        if scan not in ('SPGR', 'FSE'):
            ICE = '/Volumes/Data/Iceword/' + subj + '/Func/' + scan

            #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # Executing checkPath(path1, imgFile1, imgFile2):
            #  ++
            #       Unsure of filename configuration, but we know that the file
            #       exists in current location. checkPath() will compare the
            #       two differnt file names against the supplied path and see
            #       which one exists, then it will return the working file path.
            #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            oldImg = checkPath(OldICE,
                               '-'.join([subID, 'reg', scan.lower() + '+orig']),
                               '-'.join([subID, scan.lower(), 'reg+orig']))
            newImg = os.path.join(ICE, '-'.join([subj, scan.lower(), 'OLD.nii']))

        #---------------------------------#
        #       Structural Images         #
        #---------------------------------#
        else:

            #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # Executing checkPath(imgFile, path1, path2):
            #  ++
            #       Unsure if file exists in current location, check path will
            #       take a filename and compare it to paths to see if it exists
            #       then it will return the working file path.
            #       This is done for both the FSE and SPGR files.
            #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            oldImg = checkPath(OldICE,
                                os.path.join(OldStruct, scan.lower() + '/'),
                                '-'.join([subID, scan.lower() + '+orig']))
            newImg = os.path.join(ICEmorph, '-'.join([subj, scan.lower(), 'OLD.nii']))

        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        # Executing getImgData():
        #  ++
        #       This will copy and rename the oldImg file to the new location
        #       and name in the newImg
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        getImgData(oldImg, newImg)

        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        # Executing getImgSpec():
        #  ++
        #       This will extract the specs of the copied data and update
        #       the subjDict to reflect the information extracted.
        #       Supplied variables are the image file in question, the
        #       subject Dictionary, and the reference to subj and scan,
        #       this is done as a control check to make sure the program is
        #       outputting the correct information.
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        getImgSpec(newImg, subjDict, subj, scan)

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Executing writeReport():
    #  ++
    #       sub4dImg -- input file
    #       subStatsImg -- output file name
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    writeReport(subjDict)


if __name__ == '__main__':
    main()
