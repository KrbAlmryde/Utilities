head	1.10;
access;
symbols;
locks
	kylealmryde:1.10; strict;
comment	@# @;


1.10
date	2011.08.22.23.09.48;	author kylealmryde;	state Exp;
branches;
next	1.9;

1.9
date	2011.08.22.23.06.14;	author kylealmryde;	state Exp;
branches;
next	1.8;

1.8
date	2011.08.22.22.54.02;	author kylealmryde;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.29.18.55.47;	author kylealmryde;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.29.18.47.36;	author kylealmryde;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.29.18.25.32;	author kylealmryde;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.29.17.26.56;	author kylealmryde;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.29.17.01.31;	author kylealmryde;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.28.19.26.43;	author kylealmryde;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.27.00.31.55;	author kylealmryde;	state Exp;
branches;
next	;


desc
@I am removing the read option from the while loop too see if I cant get the shell to read the output of the function to the standard input of the while
@


1.10
log
@I also removed the $2 following the sourced exp_profile
@
text
@#!/bin/sh
# SCRIPT: call.sh
#
#
# REV: 1.0
#
# PURPOSE:
#		The purpose of this script is to act as an operator hub which
#		calls multiple independant processes to be run through a list
#		of subjects and runs in order to manipulate the standard input
#
# REV LIST:
#
#			 07/29/2011 - Kyle Almryde
#		The script has completed final testing and is ready for prime time!
#
#############################################################################
#
#		NOTE:
#		I want to include an if-then-else-fi block that would allow
#		the user the option to run a single script or to run a block of scripts
#
#############################################################################
#
# set -n	# Uncomment to check command syntax without any execution
# set -x	# Uncomment to debug this script
#
#############################################################################
#
# Sourcing the exp_profile and establishing variables
# Note: It is necessary to specify the experiment code after the exp_profile
#
. ${UTL}/exp_profile
scriptid=`basename $0`
exp=$2

#############################################################################
#
# Initiate usage_{exp} function, this wiil only apply if user does not provide
# correct input for the program to run
#

if [ $# -lt 2 ]
then
		echo "Usage: $scriptid <blk_name> <experiment_tag>"
		echo "Example: call set1 tap"
		echo "It acts as an operator hub which calls multiple independent procecesses to interact"
		echo "with each other in order to process and manipulate the standard input"
		echo "This will result in multiple processes being performed for multiple subjects and runs"
		exit 1
fi

#############################################################################
					########### START OF MAIN ############
#############################################################################

echo "#------------------------------------------ call.sh ------------------------------------------"
echo "$scriptid has been executed"
echo "	ready...."
echo "		....begin!"

#############################################################################
#
# This is the main block of the script. Through two while loops, we initiate
# a processing block containing a list of programs which can be executed
# for every subject and every run. At the completion of the block it removes all
# files with the "rm." tag, which will clean up the directories a bit.
#

while read subj; do
	 cat ${RUNS} | while read run; do

			. ${UTL}/${1}.sh ${exp}
			echo ""
			echo "Then clean up ${func_dir}/rm.* files"

			if	[ -f ${func_dir}/rm.\* ]; then
				rm -f ${func_dir}/rm.\*
			fi

	done
done <${SUBJECTS}

echo "Thats it, we are done!!"
exit 0
@


1.9
log
@I removed the efile option, I think that is what is messing up the while loop since it keeps interating over the same subject and run multiple times. In fact, I bet thats exactly what is happening.
@
text
@d33 1
a33 1
. ${UTL}/exp_profile ${2}
d73 1
a73 1
			. ${UTL}/blk_${1}_${2}.sh ${exp}
@


1.8
log
@I am removing the block concept from the script, instead I think I am going to simply run each script individually,, ie prep.sh, that way there is more overhead and maybe it will cause less problems for the shell seeing as how it keeps looping over strange things...
@
text
@a71 1
		for efile in `cat $EFILES`; do
a73 1

d80 1
a80 1
		done
@


1.7
log
@I forgot to change the #!/usr/bin/sh to #!/bin/sh when I copied the documentation format from Randy Michael's script
@
text
@d14 1
a14 1
#       07/29/2011 - Kyle Almryde
d19 3
a21 7
#       NOTE: To output the timing to a file use the following syntax:
#
#          12_ways_to_parse.ksh file_to_process  > output_file_name 2>&1
#
#       The actaul timing data is sent to standard error, file
#       descriptor (2), and the function name header is sent
#       to standard output, file descriptor (1).
d25 2
a26 2
# set -n  # Uncomment to check command syntax without any execution
# set -x  # Uncomment to debug this script
d45 6
a50 6
    echo "Usage: $scriptid <blk_name> <experiment_tag>"
    echo "Example: call set1 tap"
    echo "It acts as an operator hub which calls multiple independent procecesses to interact"
    echo "with each other in order to process and manipulate the standard input"
    echo "This will result in multiple processes being performed for multiple subjects and runs"
    exit 1
d54 1
a54 1
				########### START OF MAIN ############
d56 1
d64 1
a64 1
# This is the main engine of the script. Through two while loops, we initiate
d66 2
a67 2
# for every subject and every run. At the completion of the block it removes al
# files with the rm. tag, which will clean up the directories a little bit.
d69 1
d71 2
a72 1
	cat ${RUNS} | while read run; do
d74 1
a74 1
		. ${UTL}/blk_${1}_${2}.sh ${exp}
d76 2
a77 4
echo "			....Then clean up ${func}/rm.* files"
 		if	[ -f ${func}/rm.\* ]; then
 			rm -f ${func}/rm.\*
 		fi
d79 4
a82 1
		echo ""
d84 1
a84 1
done < ${SUBJECTS}
d86 1
a86 2
echo ""
echo "				....and we are done!!"
a87 7

#############################################################################
#
#		NOTES:
#		Next I want to include an if-then-else-fi block that would allow
#		the user to run either a single script, or to run a block of scripts
#
@


1.6
log
@Ok, I am pretty happy with this format now, I will add more documetation as I think of it etc. The call script is complete!!!!
@
text
@d1 1
a1 2
#!/usr/bin/sh
#
d46 10
a55 1
usage_${exp}
@


1.5
log
@This is the primetime version! I am happy with how the while loops are performing, and each program is being executed in the correct process - WOO HOO!
From here on I am documenting and writing instructions for use with this system.
I have yet to decide if I want to change the name of this program still...call is a decent description but its a bit ambiguious, I will have to think about it a little more. I will include a list of potential names at the next revision.
@
text
@d1 36
a36 6
#!/bin/sh
# call.sh
# This is the Call script. It acts as an operator hub which calls multiple
# independent procecesses to interact with each other in order to process and
# manipulate the standard input
#--------------------------------------------------------------------------------------------------
a38 1

d40 1
d42 4
a45 5
usage_${2}	# initiate usage_{experiment} function, this wiil only apply if user does not input
			# correct parameters into the call script.


#--------------------------------------------------------------------------------------------------
d47 1
d49 4
a52 3
exp=$2

echo "#------------------------------ call.sh ----------------------------------------------"
d57 6
a62 1
#--------------------------------------------------------------------------------------------------
a63 1

d70 3
a72 3
# 		if	[ -f ${func}/rm.\* ]; then
# 			rm -f ${func}/rm.\*
# 		fi
d82 6
a87 4


# Next I want to include an if-then-else-fi block that would allow the user to run
# either a single script, or to run a block of scripts@


1.4
log
@ Ok, so the while loop worked a little better and more in line with what I wanted it to do, so I think I am going to stick with that. In the meantime, I would like to experiment with adjusting the run variable in the for loop.
@
text
@d12 3
a14 9
if [ $# -lt 2 ]
then
    echo "Usage: $scriptid <blk_name> <experiment_tag>"
    echo "Example: call set1 tap"
    echo "It acts as an operator hub which calls multiple independent procecesses to interact"
    echo "with each other in order to process and manipulate the standard input"
    echo "This will result in multiple processes being performed for multiple subjects and runs"
    exit 1
fi
d30 1
a30 1
	for run in `cat $runloop`; do
d34 1
a34 1
#		echo "5 clean up rm.* files"
d44 1
a44 1
echo "....and we are done"
@


1.3
log
@Ok, this version works great!
I do however want to test whether or not I can implement a while loop for the $subj variable rather than nest a for loop within a for loop. Ill see what I can do with this...
@
text
@d35 2
a36 2
for subj in `echo $subloop`; do
	for run in `echo $runloop`; do
d47 1
a47 1
done
@


1.2
log
@I am adding a while/for loop to the mix to see if I cant correct this problemof not being able to pass the variables correctly through the shell
@
text
@d6 3
d10 1
a10 3
. $UTL/${2}_profile		#experiment profile


d14 1
a14 1
    echo "Usage: $0 <input_file> <experiment_code>"
d22 4
a25 1
block=$1
d27 7
a33 8
		echo "$0"
		echo `cat $UTL/call.sh`
		echo ""
		echo "======= $subj $run ========"
		echo "1 $block"
		echo "2 $exp"
		echo "3 $func"
		echo "4 $name"
d35 2
d38 1
a38 1
		${UTL}/lst_${block}_${exp}.sh ${exp}
d40 1
a40 1
		echo "5 clean up rm.* files"
d46 5
d52 5
@


1.1
log
@Initial revision
@
text
@d6 4
a9 1
. $UTL/${2}_profile
d13 1
a13 1
    echo "Usage: $0 <input file> <experiment_code>"
a21 1
exp=$2
d23 9
a31 2
while read subj; do
	for run in `cat ${RUNS}`; do
d33 6
a38 11
		echo "======= $subj $run ========"
		echo "$func"
		echo "$name"
		echo "$expr"

		${UTL}/lst_${block}_${exp}.txt ${exp}

		echo "clean up rm.* files"
		if	[ -f ${func}/rm.\* ]; then
			rm -f ${func}/rm.\*
		fi
d41 1
a41 3

	done
done <${SUBJECTS}
@
