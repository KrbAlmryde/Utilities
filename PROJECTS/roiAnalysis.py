"""
==============================================================================
Program: roiAnalysis.py
 Author: Kyle Reese Almryde
   Date: 11/20/2012 @ 13:16:12 PM

 Description: This module contains methods for performing ROI analysis on
              functional Magnetic Resonance Images.
==============================================================================
"""

import os
import sys

def filterClusters(inputFile, maskImage, outputFile):
    """Filter single subject images through clusters

    This function filters the individual subject files through the
    selected cluster images.

    Params:
        inputFile -- a 4D Image, path included, and subbrick index if
                     necessary. eg, '/path/to/image/file/4dImage.nii[1]'
        maskImage -- a binary Image intended for use as a mask, path included eg,
                     '/path/to/image/file/MaskImage.nii'
                     NOTE: it is optional for the image to be in binary format
        outputFile -- a 4D Image, path included, describing the desired output
                      file name: '/path/to/image/file/4dImageMasked.nii'
    """
    os.system('3drefit -space MNI ' + maskImage)
    os.system('3dcalc -a ' + maskImage \
               + ' -b ' + inputFile \
               + " -expr 'step(a) * b'" \
               + ' -prefix ' + outputFile)



def flipXYZ(oldXYZ):   # This is an example of a nice Modular function.
    """Flip XY coords of an XYZ coordinate string

    This function inverts the xy coordinates generated by afni's
    3dclust command. It is presently acting as a sort of Helper
    function to getClusterStats function defined below.

    Params:
        oldXYZ -- a string containing the original xyz coordinates
                  oldXYZ == '58 42 8'
    Returns:
        xyz -- a new string with the inverted xy + z coordinates
                xyz == '-58 -42 8'
    """
    coordList = oldXYZ.split()
    x = int(coordList[0]) * -1
    y = int(coordList[1]) * -1
    xyz = ' '.join([str(x), str(y), coordList[2]])
    return xyz


def whereAmI(xyz):      # This is a good Modular function
    """Get the region of interest from the supplied xyz coordinates

    This function utilizes afni's CA_ML_18_MNIA atlas and reads xyz
    coordinates in -lpi orientation. It returns only the first listed
    roi, so if more detail is desired regarding the surrounding regions
    this function may not be the most ideal.

    Params:
        xyz -- a string of three numbers representing xyz coordinates
                '-50 48 2'

    Returns:
        A string representing the region of interest
    """
    atlas = os.popen('whereami ' + xyz + ' -atlas CA_ML_18_MNIA -lpi').readlines()
    index = atlas.index('Atlas CA_ML_18_MNIA: Macro Labels (N27)\n')
    roi = atlas[index + 1].split(':')[1].strip().split()
    return roi[0] + '\t' + ' '.join(roi[1:])


def getClusterStats(imgFile):   # This has potential to be very Modular, I just need to decide if I like it enough
    """Extract cluster stats from image file

    This function uses the os mondule popen to capture output from
    afni's 3dclust command. Presently it assumes the image is in
    2x2x2 resolution. Output is the mean and peak voxel intensity
    followed by the peak xyz coordinates

    Params:
        imgFile -- a 4D Image, path included eg,
                   '/path/to/image/file/4dImage.nii.gz'

    Returns:
        stats -- a string containing the values for mean, peak, xyz, and roi
    """
    clusterTbl = os.popen('3dclust 2 1 ' + imgFile).readlines()[-1].strip()  # Strip newline and get last line with the stats output table from 3dclust
    tempXyz = ' '.join(clusterTbl.split()[-3:]).replace('.0', '')  # Strip the '.0' from the coordinate numbers.

    mean = os.popen('3dBrickStat -mean ' + imgFile).readline().strip()  # get the mean of the image file
    peak = clusterTbl.split()[-4]   # a list object containing the [peak intensity, Xcoord, Ycoord, Zcoord]
    xyz = flipXYZ(tempXyz)  # Use the flipXYZ function to flip the x and y coordinates (name is a bit misleading)
    roi = whereAmI(xyz)  # Extract the Region of Interest based on the supplied xyz coordinates

    return ' '.join([mean, peak, xyz, roi])


# def groupImageStats(imgFile, brik='', outImage):
#     """ Strip the desired image statistics from the image file

#     Specifically, remove those subbricks from specified from the
#     supplied image, and store them in their own file that can be
#     manipulated more easily later on.

#     Params:
#         imgFile -- The input 4d file. It can be a subject image
#                    file or a group image file, so long as at
#                    least 2 subbricks reside within the image.
#                    The image should contain the desired path.
#                    '/path/to/image/file/4dImage.nii.gz'
#                    Optionally, a list of 4d images can be supplied
#                    in which case a string will be constructed
#                    using a list comprehension.

#         brik -- The desired subbrik(s) to be extracted. AFNI
#                 conventions for specifying subbriks apply.

#         outImage -- The desired prefix for the newly created
#                   image file. The path name should be included
#                   in the image prefix

#     Returns:
#          A string composed of the output image's path and name,
#          in case it is needed.

#     """
#     if type(imgFile) == list:
#         imgFile = ' '.join([x + brik for x in imgFile])
#     else:
#         imgFile = imgFile + brik

#     os.system('3dbucket -prefix ' + outImage + ' ' + imgFile)
#     return outImage


# def computeImageMean(imgList, brik='', outImage):
#     """ using 3dmean, average datasets

#     Params:
#         imgList -- A list of 4d images to be averaged. It is assumed
#                    the list has already been stripped.

#         brik -- an optional parameter which can specify a subbrik.

#         outImage -- The desired prefix for the newly created
#                   image file. The path name should be included
#                   in the image prefix

#     Returns:
#          A string composed of the output image's path and name,
#          in case it is needed.
#     """
#     imgFiles = ' '.join([x + brik for x in imgList])

#     os.system('3dMean -prefix ' + outImage + ' ' + imgFiles)
#     return outImage


# def oneSample_tTest(imgList, maskFile, brik='', outImage):
#     """ perform a one sample tTest

#     Params:
#         imgList --
#         maskFile --
#         brik --
#         outImage --

#     Returns:
#          Description of returns
#     """
#     if type(imgFile) == list:
#         imgFile = ' '.join([x + brik for x in imgFile])
#     else:
#         imgFile = imgFile + brik


#     os.system('3dttest++ -setA ' + imgFiles
#                + ' -mask ' + maskFile
#                + ' -prefix ' + outImage)
